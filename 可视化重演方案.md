# 软件可视化重演方案

采用 vue3 + flask + nginx 做 web 服务实现可视化

vue3 router 单页面插件预留其他操作接口。

前后端分离，后端处理所有数据，不打算用数据库。

可视化重演流程：
1. 进行实验，生成日志和剧本
2. web 服务读取剧本
3. vue 前端服务可视化渲染

实现功能：replay 重演实验过程

原始剧本每一行格式：
```json
{"type":0,"tool":"b","msg":["msg1"]}
{"type":0,"tool":"c","msg":["msg2"]}
{"type":0,"tool":"c","from":["msg3"]}
{"type":1,"tool":"c","from":["msg3-a"]}
{"type":1,"tool":"c","from":["msg2-a"]}
{"type":0,"tool":"c","from":["msg4"]}
{"type":1,"tool":"c","from":["msg4-a"]}
{"type":1,"tool":"b","msg":["msg1-a1","msg1-a2","msg1-a3","msg1-a99"]}
```
说明：
- type: 0|1 开始/结果
- tool: b|c 一对一/一对多
- msg: [] 消息列表，发的什么就写什么尽量减少 IO 时间

解析剧本：

堆栈解析，然后缓存 JSON 文件，JSON 文件里面存储的就是 scene 数组，这两后续读取速度快。

解析方案：
- 一行一行读取剧本
- 获取 id，name，然后绑定立绘 
  - imgs = ['boy_'+ str(i+1) for i in range(8)] + ['girl_'+str(i+1) for i in range(8)]
  - random.shuffle(imgs)
  - 然后一个 name[] 数组用于缓存用到的角色，两个一一对应
- 然后栈堆解析对话，基本两行一个scene，如果中间有其他动作，则将对话拆开。
- 转换为 JSON 缓存形式

剧本功能：

- 写在交互工具层，因为剧本的基础就是交互
- 工具调用开始使用一次 IO 追加读写，结束时使用一次 IO 追加读写
- 剧本文件一行一行写入，以栈堆的形式存储QA
- 后端读取解析，采用缓存的方式读取，优先读缓存 json，读不了再去读原剧本